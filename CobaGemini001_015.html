<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soccer Bounce Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 10px; /* Reduced padding for smaller screens */
            background: linear-gradient(135deg, #2c5234, #1a3d20);
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Arial', sans-serif;
            color: white;
            min-height: 100vh;
            box-sizing: border-box;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 400px; /* Max width for larger screens, allows centering */
            margin: 0 auto; /* Center the game container */
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #hud {
            width: 100%; /* Full width of its container */
            max-width: 360px; /* Consistent with canvas logical width */
            height: 50px;
            background: linear-gradient(45deg, #1a3d20, #2c5234);
            border: 2px solid white;
            border-radius: 7px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px; /* Adjusted padding */
            margin-bottom: 10px;
            font-size: clamp(14px, 4vw, 18px); /* Responsive font size */
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            box-sizing: border-box;
        }
        /* New HUD element for player name */
        #playerNameHUD {
            position: absolute;
            top: 10px; /* Adjust as needed */
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(12px, 3.5vw, 16px);
            color: #FFD700;
            font-weight: bold;
            z-index: 10;
        }

        #gameCanvas {
            border: 3px solid white;
            border-radius: 10px;
            cursor: none;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            display: block; /* Removes extra space below canvas */
            width: 100%; /* Make canvas responsive */
            height: auto; /* Maintain aspect ratio */
            aspect-ratio: 360 / 610; /* Game's logical aspect ratio */
            max-height: 85vh; /* Prevent canvas from being too tall on portrait */
            background-color: #4CAF50; /* Fallback for canvas content */
        }

        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 10px; /* Padding for modal itself on small screens */
            box-sizing: border-box;
        }

        .modal-content {
            background: linear-gradient(145deg, #2c5234, #1a3d20);
            padding: clamp(20px, 5vw, 40px); /* Responsive padding */
            border-radius: 20px;
            text-align: center;
            border: 3px solid #4CAF50;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.5);
            max-width: 350px; /* Max width for content */
            width: 90%; /* Relative width */
            box-sizing: border-box;
        }

        .modal h1 {
            color: #4CAF50;
            font-size: clamp(24px, 6vw, 32px);
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .modal h2 {
            color: #FFD700;
            font-size: clamp(20px, 5.5vw, 28px);
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .modal p {
            font-size: clamp(14px, 3.5vw, 16px);
        }

        .vs-text {
            font-size: clamp(18px, 4.5vw, 24px);
            color: #FF6B6B;
            font-weight: bold;
            margin: 15px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .score-display {
            font-size: clamp(28px, 7vw, 36px);
            color: #4CAF50;
            margin: 15px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .button-container {
            display: flex;
            flex-direction: column;
            gap: 10px; /* Reduced gap */
            margin-top: 20px;
        }

        button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 12px 25px; /* Adjusted padding */
            font-size: clamp(14px, 4vw, 16px);
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            font-weight: bold;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
            background: linear-gradient(45deg, #45a049, #4CAF50);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #FF6B6B, #FF5252);
        }

        .btn-secondary:hover {
            background: linear-gradient(45deg, #FF5252, #FF6B6B);
        }

        .btn-tertiary {
            background: linear-gradient(45deg, #FFA726, #FF9800);
        }

        .btn-tertiary:hover {
            background: linear-gradient(45deg, #FF9800, #FFA726);
        }

        #startMenu, #gameOver, #leaderboard {
            display: none; /* Initially hidden, controlled by JS */
        }

        .firework {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            animation: firework-explode 1s ease-out forwards; /* Use forwards */
            pointer-events: none;
            z-index: 1002;
        }

        @keyframes firework-explode {
            0% {
                transform: translate(0, 0) scale(0);
                opacity: 1;
            }
            100% {
                transform: translate(var(--dx), var(--dy)) scale(20);
                opacity: 0;
            }
        }

        .confetti {
            position: absolute;
            width: 8px;
            height: 8px;
            background: white; /* Default, overridden by JS */
            border-radius: 50%; /* Make it circular */
            opacity: 0;
            transform: scale(0);
            animation: confetti-fall var(--duration) ease-out forwards;
            pointer-events: none;
            z-index: 1001;
        }

        @keyframes confetti-fall {
            0% {
                transform: translate(0, 0) scale(0);
                opacity: 1;
            }
            20% {
                transform: translate(var(--dx), var(--dy)) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--dx), calc(100vh - var(--dy) - 50%)) scale(0.5); /* Fall towards bottom */
                opacity: 0;
            }
        }

        .goal-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(36px, 10vw, 48px); /* Responsive font size */
            color: #FFD700;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            animation: goal-popup 2s ease-out forwards;
            pointer-events: none;
            z-index: 999;
        }

        @keyframes goal-popup {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="hud">
            <div>Player: <span id="playerScore">0</span></div>
            <div>Time: <span id="timeDisplay">90</span>s</div>
            <div>Computer: <span id="computerScore">0</span></div>
        </div>
        <div id="playerNameHUD"></div> <canvas id="gameCanvas" width="360" height="610"></canvas>

        <div id="startMenu" class="modal" style="display: flex;">
            <div class="modal-content">
                <h2>‚öΩ SOCCER ‚öΩ</h2>
                <div class="vs-text">Player vs Computer</div>
                <p>Gunakan mouse atau sentuhan untuk menggerakkan paddle dan cetak gol sebanyak-banyaknya dalam 90 detik!</p>
                <div class="button-container">
                    <button onclick="startGame()">üéÆ Start Game</button>
                    <button class="btn-tertiary" onclick="showLeaderboard()">üèÜ Story</button>
                    <button class="btn-tertiary" onclick="goToGlobalLeaderboard()">üåê Global Leaderboard</button>
                    <button class="btn-secondary" onclick="goToLogin()">üö™ Exit to Login</button>
                </div>
            </div>
        </div>

        <div id="gameOver" class="modal">
            <div class="modal-content">
                <div id="finalResult"></div>
                <div class="button-container">
                    <button onclick="restartGame()">üîÑ Play Again</button>
                    <button class="btn-tertiary" onclick="showLeaderboard()">üèÜ Story</button>
                    <button class="btn-tertiary" onclick="goToGlobalLeaderboard()">üåê Global Leaderboard</button>
                    <button class="btn-secondary" onclick="goToLogin()">üö™ Exit to Login</button>
                </div>
            </div>
        </div>

        <div id="leaderboard" class="modal">
            <div class="modal-content">
                <h2>üèÜ STORY üèÜ</h2>
                <div id="leaderboardContent" style="max-height: 200px; overflow-y: auto;">
                    <p>Belum ada data permainan</p>
                </div>
                <div class="button-container">
                    <button onclick="hideLeaderboard()">üîô BACK</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let gameRunning = false;
        let gameTime = 90; // seconds
        let playerScore = 0;
        let computerScore = 0;
        let gameTimer;
        let gameStarted = false; // To track if a game has been started at least once

        // Player Name
        let currentPlayerName = "Guest"; // Default player name

        // Variabel untuk tingkat kesulitan adaptif
        let initialPaddleWidth;
        const minPaddleWidthRatio = 0.4;
        let paddleShrinkRate;

        let initialBallSpeed;
        const maxBallSpeedIncreaseRatio = 0.7;
        let ballSpeedIncreaseRate;

        const maxGameSpeed = 20;
        const ORIGINAL_PADDLE_WIDTH = 90;

        // Game objects
        const ball = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 8,
            dx: 0,
            dy: 0,
            speed: 7,
            normalSpeed: 6.2,
        };

        // Ball trail properties
        const ballTrail = [];
        const maxTrailLength = 15;
        const trailDecay = 0.05;

        const paddle = {
            x: (canvas.width - ORIGINAL_PADDLE_WIDTH) / 2,
            y: canvas.height - 15 - 15,
            width: ORIGINAL_PADDLE_WIDTH,
            height: 11
        };

        const goal = {
            x: (canvas.width - 100) / 2,
            y: 0,
            width: 72,
            height: 20
        };

        // Obstacles with properties for random movement
        const obstacles = [
            { x: 180, y: 40, radius: 12, initialX: 180, initialY: 40, moveRange: 33, speed: 3, targetX: null, targetY: null, isSpecial: true },
            { x: 80, y: 120, radius: 12, initialX: 80, initialY: 120, moveRange: 70, speed: 1.5, targetX: null, targetY: null},
            { x: 280, y: 180, radius: 12, initialX: 280, initialY: 180, moveRange: 80, speed: 2, targetX: null, targetY: null },
            { x: 150, y: 240, radius: 12, initialX: 150, initialY: 240, moveRange: 70, speed: 1.8, targetX: null, targetY: null },
            { x: 150, y: 300, radius: 12, initialX: 150, initialY: 300, moveRange: 80, speed: 2.3, targetX: null, targetY: null, isSpecial: true },
            { x: 150, y: 450, radius: 12, initialX: 150, initialY: 500, moveRange: 75, speed: 2.7, targetX: null, targetY: null }
        ];

        let gameHistory = []; // Local game history (player's session history)
        let globalGameHistory = []; // Global game history (all players)

        // Initialize Tone.js for sound effects
        const kickSynth = new Tone.MembraneSynth().toDestination();
        const cheerNoise = new Tone.NoiseSynth({
            noise: { type: "white" },
            envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 }
        }).toDestination();
        const sadSynth = new Tone.FMSynth({
            harmonicity: 3.0, modulationIndex: 10,
            envelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.5 },
            modulation: { type: "sine" },
            modulationEnvelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.5 }
        }).toDestination();

        function playKickSound() { kickSynth.triggerAttackRelease("C2", "8n"); }
        function playCheerSound() { cheerNoise.triggerAttackRelease("0.5"); }
        function playSadSound() { sadSynth.triggerAttackRelease("D3", "0.4"); }

        function normalizeBallSpeed() {
            const currentDirSpeed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
            if (currentDirSpeed > 0) {
                ball.dx = (ball.dx / currentDirSpeed) * ball.speed;
                ball.dy = (ball.dy / currentDirSpeed) * ball.speed;
            } else if (ball.speed > 0) {
                // If currentDirSpeed is 0 but ball.speed > 0, give it a random direction
                ball.dx = (Math.random() - 0.5) * 2 * ball.speed / Math.sqrt(2);
                ball.dy = (Math.random() > 0.5 ? 1 : -1) * Math.sqrt(ball.speed*ball.speed - ball.dx*ball.dx) || -ball.speed / Math.sqrt(2);
            }
        }

        function showModal(modalId) {
            ['startMenu', 'gameOver', 'leaderboard'].forEach(id => {
                document.getElementById(id).style.display = 'none';
            });
            document.getElementById(modalId).style.display = 'flex';
        }

        window.onload = () => {
            // Get current player name from localStorage
            const storedPlayerName = localStorage.getItem('currentPlayerName');
            if (storedPlayerName) {
                currentPlayerName = storedPlayerName;
            } else {
                // If no player name, redirect to login page (index.html)
                goToLogin();
                return; // Stop further execution
            }
            document.getElementById('playerNameHUD').textContent = `Player: ${currentPlayerName}`;

            showModal('startMenu');
            updateHUD();
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            paddle.x = (canvas.width - paddle.width) / 2;
            paddle.y = canvas.height - paddle.height - 15;
            goal.x = (canvas.width - goal.width) / 2;

            // Load global game history
            loadGlobalGameHistory();

            // Load session game history (player's local history)
            loadSessionGameHistory();
        };

        function loadSessionGameHistory() {
            try {
                const savedSessionHistory = window.localStorage?.getItem('soccerBounceHistory');
                if (savedSessionHistory) {
                    gameHistory = JSON.parse(savedSessionHistory);
                }
            } catch (e) {
                console.warn('LocalStorage not available or session history corrupted, using empty array.');
                gameHistory = [];
            }
        }

        function loadGlobalGameHistory() {
            try {
                const savedGlobalHistory = window.localStorage?.getItem('soccerBounceGlobalHistory');
                if (savedGlobalHistory) {
                    globalGameHistory = JSON.parse(savedGlobalHistory);
                }
            } catch (e) {
                console.warn('LocalStorage not available or global history corrupted, using empty array.');
                globalGameHistory = [];
            }
        }

        function saveGlobalGameHistory() {
            try {
                if (window.localStorage) {
                    window.localStorage.setItem('soccerBounceGlobalHistory', JSON.stringify(globalGameHistory));
                }
            } catch (e) {
                console.warn('Cannot save to localStorage.');
            }
        }

        function startGame() {
            if (Tone.context.state !== 'running') {
                Tone.start();
            }

            showModal('gameCanvas'); // This actually just hides all modals, canvas is always there
            document.getElementById('startMenu').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('leaderboard').style.display = 'none'; // Ensure session history modal is hidden

            gameRunning = true;
            gameStarted = true; // Mark game as started
            gameTime = 90;
            playerScore = 0;
            computerScore = 0;

            paddle.width = ORIGINAL_PADDLE_WIDTH;
            paddle.x = (canvas.width - paddle.width) / 2;

            initialPaddleWidth = paddle.width;
            initialBallSpeed = ball.normalSpeed;
            paddleShrinkRate = (initialPaddleWidth * (1 - minPaddleWidthRatio)) / gameTime;
            ballSpeedIncreaseRate = (initialBallSpeed * maxBallSpeedIncreaseRatio) / gameTime;

            obstacles.forEach(obstacle => {
                obstacle.x = obstacle.initialX;
                obstacle.y = obstacle.initialY;
                obstacle.targetX = null;
                obstacle.targetY = null;
            });

            resetBall();
            updateHUD();

            if (gameTimer) clearInterval(gameTimer);
            gameTimer = setInterval(() => {
                gameTime--;
                updateHUD();
                updateDifficulty();
                if (gameTime <= 0) {
                    clearInterval(gameTimer);
                    endGame();
                }
            }, 1000);

            gameLoop();
        }

        function updateDifficulty() {
            if (!gameRunning) return;
            paddle.width = Math.max(initialPaddleWidth * minPaddleWidthRatio, paddle.width - paddleShrinkRate);
            ball.speed = Math.min(initialBallSpeed * (1 + maxBallSpeedIncreaseRatio), ball.speed + ballSpeedIncreaseRate);
            normalizeBallSpeed();
        }

        function createConfetti(x, y) {
            const colors = ['#FFD700', '#FF6B6B', '#4CAF50', '#2196F3', '#FF9800', '#9C27B0'];
            const gameContainer = document.getElementById('gameContainer');
            const canvasRect = canvas.getBoundingClientRect();

            for (let i = 0; i < 50; i++) {
                const confettiEl = document.createElement('div');
                confettiEl.className = 'confetti';

                const scaleX = canvasRect.width / canvas.width;
                const scaleY = canvasRect.height / canvas.height;

                const screenX = x * scaleX + canvasRect.left - gameContainer.getBoundingClientRect().left;
                const screenY = y * scaleY + canvasRect.top - gameContainer.getBoundingClientRect().top;

                confettiEl.style.left = screenX + 'px';
                confettiEl.style.top = screenY + 'px';
                confettiEl.style.background = colors[Math.floor(Math.random() * colors.length)];
                confettiEl.style.animationDelay = Math.random() * 0.5 + 's';
                confettiEl.style.transform = `rotate(${Math.random() * 360}deg)`;

                const angle = Math.random() * Math.PI * 2;
                const velocity = 10 + Math.random() * 15;
                const duration = 2 + Math.random() * 1;
                confettiEl.style.setProperty('--dx', Math.cos(angle) * velocity + 'px');
                confettiEl.style.setProperty('--dy', Math.sin(angle) * velocity + 'px');
                confettiEl.style.setProperty('--duration', duration + 's');

                gameContainer.appendChild(confettiEl);
                setTimeout(() => { if (confettiEl.parentNode) confettiEl.remove(); }, duration * 1000);
            }
        }

        function createFireworks(x, y) {
            const colors = ['#FFD700', '#FF4444', '#44FF44', '#4444FF', '#FF44FF'];
            const gameContainer = document.getElementById('gameContainer');
            const canvasRect = canvas.getBoundingClientRect();

            for (let i = 0; i < 15; i++) {
                const fireworkEl = document.createElement('div');
                fireworkEl.className = 'firework';

                const scaleX = canvasRect.width / canvas.width;
                const scaleY = canvasRect.height / canvas.height;
                const screenX = x * scaleX + canvasRect.left - gameContainer.getBoundingClientRect().left;
                const screenY = y * scaleY + canvasRect.top - gameContainer.getBoundingClientRect().top;

                fireworkEl.style.left = screenX + 'px';
                fireworkEl.style.top = screenY + 'px';
                fireworkEl.style.background = colors[Math.floor(Math.random() * colors.length)];

                const angle = Math.random() * Math.PI * 2;
                const distance = 30 + Math.random() * 40;
                fireworkEl.style.setProperty('--dx', Math.cos(angle) * distance + 'px');
                fireworkEl.style.setProperty('--dy', Math.sin(angle) * distance + 'px');

                gameContainer.appendChild(fireworkEl);
                setTimeout(() => { if (fireworkEl.parentNode) fireworkEl.remove(); }, 1000);
            }
        }

        function showGoalMessage() {
            const message = document.createElement('div');
            message.className = 'goal-message';
            message.textContent = 'GOOOAL!';
            document.getElementById('gameContainer').appendChild(message);
            setTimeout(() => { if(message.parentNode) message.remove(); }, 2000);
        }

        function drawField() {
            ctx.fillStyle = '#4CAF50';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, canvas.height / 2); ctx.lineTo(canvas.width, canvas.height / 2); ctx.stroke();
            ctx.beginPath(); ctx.arc(canvas.width / 2, canvas.height / 2, 70, 0, Math.PI * 2); ctx.stroke();
            ctx.beginPath(); ctx.rect(goal.x - 40, goal.y, goal.width + 80, 90); ctx.stroke();
        }

        function drawGoal() {
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 4;
            ctx.beginPath(); ctx.moveTo(goal.x, goal.y); ctx.lineTo(goal.x, goal.y + goal.height); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(goal.x + goal.width, goal.y); ctx.lineTo(goal.x + goal.width, goal.y + goal.height); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(goal.x, goal.y); ctx.lineTo(goal.x + goal.width, goal.y); ctx.stroke();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1;
            for (let i = 10; i < goal.width; i += 10) { ctx.beginPath(); ctx.moveTo(goal.x + i, goal.y); ctx.lineTo(goal.x + i, goal.y + goal.height); ctx.stroke(); }
            for (let i = 8; i < goal.height; i += 8) { ctx.beginPath(); ctx.moveTo(goal.x, goal.y + i); ctx.lineTo(goal.x + goal.width, goal.y + i); ctx.stroke(); }
        }

        function drawPaddle() {
            ctx.fillStyle = '#2196F3';
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.strokeRect(paddle.x, paddle.y, paddle.width, paddle.height);
        }

        function drawBall() {
            if (Math.abs(ball.dx) > 0.5) { // Only draw trail if ball is moving significantly
                for (let i = 0; i < ballTrail.length; i++) {
                    const trail = ballTrail[i];
                    const opacity = (i / maxTrailLength) * (1 - trailDecay) + trailDecay;
                    ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                    ctx.beginPath();
                    ctx.arc(trail.x, trail.y, ball.radius * (i / maxTrailLength * 0.5 + 0.5), 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(ball.x + 1, ball.y + 1, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fill();
        }

        function drawObstacles() {
            obstacles.forEach(obstacle => {
                if (obstacle.isSpecial) {
                    ctx.fillStyle = '#000000';
                } else {
                    ctx.fillStyle = '#333';
                }
                ctx.beginPath();
                ctx.arc(obstacle.x, obstacle.y, obstacle.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }

        function updateBall() {
            ball.x += ball.dx;
            ball.y += ball.dy;
            ballTrail.push({ x: ball.x, y: ball.y });
            if (ballTrail.length > maxTrailLength) { ballTrail.shift(); }

            // Player scores
            if (ball.dy < 0 && ball.y - ball.radius < goal.y + goal.height && ball.y + ball.radius > goal.y && ball.x > goal.x && ball.x < goal.x + goal.width) {
                if (ball.y - ball.radius <= goal.y + 5) { // Ensure it really crosses the line
                    playerScore++;
                    updateHUD();
                    showGoalMessage();
                    createConfetti(ball.x, ball.y);
                    createFireworks(ball.x, ball.y);
                    playCheerSound();
                    resetBall();
                    return;
                }
            }

            // Wall collisions (left/right)
            if (ball.x - ball.radius <= 0) {
                ball.dx = -ball.dx; ball.x = ball.radius; ball.dy += (Math.random() - 0.5) * 0.5; normalizeBallSpeed();
            } else if (ball.x + ball.radius >= canvas.width) {
                ball.dx = -ball.dx; ball.x = canvas.width - ball.radius; ball.dy += (Math.random() - 0.5) * 0.5; normalizeBallSpeed();
            }

            // Top wall collision (if not in goal area)
            if (ball.dy < 0 && ball.y - ball.radius <= 0 && !(ball.x > goal.x && ball.x < goal.x + goal.width)) {
                ball.dy = -ball.dy; ball.y = ball.radius; ball.dx += (Math.random() - 0.5) * 0.5; normalizeBallSpeed();
            }

            // Goal post/side collisions
            const sensitiveZoneWidth = 10;
            const sensitiveZoneHeight = 50; // How deep the goal area extends for side bounces
            const goalSideBoostFactor = 1.5;

            // Left side of goal area
            if (ball.dy < 0 && ball.x - ball.radius <= sensitiveZoneWidth && ball.x + ball.radius > 0 && ball.y - ball.radius < (goal.y + sensitiveZoneHeight) && ball.y + ball.radius > goal.y) {
                if (ball.x + ball.radius < goal.x - 55) { // Only bounce if it's outside the main goal opening
                    ball.dx = -ball.dx;
                    ball.speed = Math.min(ball.speed * goalSideBoostFactor, maxGameSpeed); // Speed up for hitting sides
                    ball.dy += (Math.random() - 0.5) * 0.7; // Add some randomness
                    normalizeBallSpeed();
                    ball.x = sensitiveZoneWidth + ball.radius + 0.1; // Reposition to prevent sticking
                }
            }

            // Right side of goal area
            if (ball.dy < 0 && ball.x + ball.radius >= canvas.width - sensitiveZoneWidth && ball.x - ball.radius < canvas.width && ball.y - ball.radius < (goal.y + sensitiveZoneHeight) && ball.y + ball.radius > goal.y) {
                if (ball.x - ball.radius > goal.x + goal.width + 55) { // Only bounce if it's outside the main goal opening
                    ball.dx = -ball.dx;
                    ball.speed = Math.min(ball.speed * goalSideBoostFactor, maxGameSpeed);
                    ball.dy += (Math.random() - 0.5) * 0.7;
                    normalizeBallSpeed();
                    ball.x = canvas.width - sensitiveZoneWidth - ball.radius - 0.1;
                }
            }

            // Actual goal post collisions (inside the goal area)
            if (ball.y - ball.radius < goal.y + goal.height && ball.y + ball.radius > goal.y) {
                // Left goal post
                if (ball.dx < 0 && (ball.x - ball.radius) < goal.x && (ball.x + ball.radius) > goal.x ) {
                     if(ball.x > goal.x - ball.radius - 5 && ball.x < goal.x + 5){ // Close enough to post
                        ball.dx = -ball.dx; ball.x = goal.x + ball.radius + 0.1; // Reposition
                        ball.speed = Math.min(ball.speed * 2, maxGameSpeed); // Strong bounce
                        ball.dy += (Math.random() - 0.5) * 0.7; normalizeBallSpeed();
                     }
                }
                // Right goal post
                else if (ball.dx > 0 && (ball.x + ball.radius) > (goal.x + goal.width) && (ball.x - ball.radius) < (goal.x + goal.width) ) {
                    if(ball.x < goal.x + goal.width + ball.radius + 5 && ball.x > goal.x + goal.width - 5){ // Close enough to post
                        ball.dx = -ball.dx; ball.x = (goal.x + goal.width) - ball.radius - 0.1; // Reposition
                        ball.speed = Math.min(ball.speed * 2, maxGameSpeed);
                        ball.dy += (Math.random() - 0.5) * 0.7; normalizeBallSpeed();
                    }
                }
            }


            // Paddle collision
            if (ball.dy > 0 && ball.y + ball.radius >= paddle.y && ball.y - ball.radius <= paddle.y + paddle.height && ball.x + ball.radius >= paddle.x && ball.x - ball.radius <= paddle.x + paddle.width) {
                ball.dy = -ball.dy;
                ball.y = paddle.y - ball.radius - 0.1; // Reposition to prevent sticking
                ball.speed = initialBallSpeed; // Reset speed after hitting paddle
                // Calculate bounce angle based on where it hit the paddle
                const hitPos = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2); // -1 to 1
                ball.dx = hitPos * ball.speed * 1.0; // Adjust multiplier for stronger horizontal bounce
                normalizeBallSpeed();
                playKickSound();
            }

            // Bottom collision (computer scores)
            if (ball.y + ball.radius >= canvas.height) {
                computerScore++;
                updateHUD();
                playSadSound();
                resetBall();
                return;
            }

            // Obstacle collisions
            obstacles.forEach(obstacle => {
                const dx_obs = ball.x - obstacle.x;
                const dy_obs = ball.y - obstacle.y;
                const distance = Math.sqrt(dx_obs*dx_obs + dy_obs*dy_obs);

                if (distance < ball.radius + obstacle.radius) {
                    const overlap = ball.radius + obstacle.radius - distance;
                    // Push ball out of obstacle
                    ball.x += Math.cos(Math.atan2(dy_obs, dx_obs)) * overlap;
                    ball.y += Math.sin(Math.atan2(dy_obs, dx_obs)) * overlap;

                    if (obstacle.isSpecial) {
                        // Special obstacles: always reflect ball towards the paddle
                        ball.dy = Math.abs(ball.dy); // Force ball downwards
                        const paddleCenterX = paddle.x + paddle.width / 2;
                        const directionToPaddleX = paddleCenterX - ball.x;
                        ball.dx = directionToPaddleX * (ball.speed / (Math.abs(directionToPaddleX) + Math.abs(ball.dy)));
                        if (isNaN(ball.dx)) { ball.dx = (Math.random() - 0.5) * 2; } // Fallback for division by zero
                    } else {
                        // Regular obstacles: reflect based on collision angle
                        const angle = Math.atan2(dy_obs, dx_obs);
                        ball.dx = Math.cos(angle) * ball.speed;
                        ball.dy = Math.sin(angle) * ball.speed;
                        ball.dx += (Math.random() - 0.5) * 0.5; // Add slight randomness
                        ball.dy += (Math.random() - 0.5) * 0.5;
                    }
                    normalizeBallSpeed();
                    playKickSound();
                }
            });
        }

        function updateObstacles() {
            obstacles.forEach(obstacle => {
                if (obstacle.targetX === null || obstacle.targetY === null ||
                    Math.sqrt(Math.pow(obstacle.x - obstacle.targetX, 2) + Math.pow(obstacle.y - obstacle.targetY, 2)) < obstacle.speed) {
                    // Set a new random target within its move range
                    obstacle.targetX = obstacle.initialX + (Math.random() * 2 - 1) * obstacle.moveRange;
                    obstacle.targetY = obstacle.initialY + (Math.random() * 2 - 1) * obstacle.moveRange;
                    // Clamp targets to canvas bounds
                    obstacle.targetX = Math.max(obstacle.radius, Math.min(canvas.width - obstacle.radius, obstacle.targetX));
                    obstacle.targetY = Math.max(obstacle.radius, Math.min(canvas.height - obstacle.radius, obstacle.targetY));
                    const angle = Math.atan2(obstacle.targetY - obstacle.y, obstacle.targetX - obstacle.x);
                    obstacle.dx = Math.cos(angle) * obstacle.speed;
                    obstacle.dy = Math.sin(angle) * obstacle.speed;
                }
                obstacle.x += obstacle.dx;
                obstacle.y += obstacle.dy;

                // Simple boundary check for obstacles (bounce off walls)
                if (obstacle.x - obstacle.radius < 0) { obstacle.x = obstacle.radius; obstacle.dx *= -1; obstacle.targetX = null; }
                else if (obstacle.x + obstacle.radius > canvas.width) { obstacle.x = canvas.width - obstacle.radius; obstacle.dx *= -1; obstacle.targetX = null; }
                if (obstacle.y - obstacle.radius < 0) { obstacle.y = obstacle.radius; obstacle.dy *= -1; obstacle.targetY = null; }
                else if (obstacle.y + obstacle.radius > canvas.height) { obstacle.y = canvas.height - obstacle.radius; obstacle.dy *= -1; obstacle.targetY = null; }
            });
        }

        function updatePaddle(inputX) {
            if (inputX === undefined) return;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const canvasMouseX = (inputX - rect.left) * scaleX;
            paddle.x = canvasMouseX - paddle.width / 2;
            // Clamp paddle to canvas bounds
            if (paddle.x < 0) paddle.x = 0;
            if (paddle.x + paddle.width > canvas.width) {
                paddle.x = canvas.width - paddle.width;
            }
        }

        function resetBall() {
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            ball.speed = initialBallSpeed; // Reset ball speed
            ball.dy = -ball.speed; // Always start moving upwards
            ball.dx = (Math.random() > 0.5 ? 1 : -1) * (ball.speed * 0.7); // Random horizontal direction
            normalizeBallSpeed(); // Ensure dx/dy adhere to speed
            ballTrail.length = 0; // Clear ball trail
        }

        function updateHUD() {
            document.getElementById('playerScore').textContent = playerScore;
            document.getElementById('computerScore').textContent = computerScore;
            document.getElementById('timeDisplay').textContent = gameTime;
            document.getElementById('playerNameHUD').textContent = `Player: ${currentPlayerName}`; // Update player name in HUD
        }

        function gameLoop() {
            if (!gameRunning) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawField();
            drawGoal();
            drawPaddle();
            drawObstacles();
            drawBall();
            updateBall();
            updateObstacles();
            requestAnimationFrame(gameLoop);
        }

        function endGame() {
            gameRunning = false;
            clearInterval(gameTimer);

            const gameResult = {
                playerName: currentPlayerName, // Store player name
                date: new Date().toLocaleDateString('id-ID', { day: '2-digit', month: 'short', year: 'numeric' }),
                playerScore: playerScore,
                computerScore: computerScore,
                result: playerScore > computerScore ? 'Win' : (computerScore > playerScore ? 'Lose' : 'Draw')
            };

            // Store in local game history (player's session)
            gameHistory.unshift(gameResult); // Add to beginning
            if (gameHistory.length > 10) gameHistory = gameHistory.slice(0, 10); // Keep only last 10 games
            try {
                if (window.localStorage) {
                    window.localStorage.setItem('soccerBounceHistory', JSON.stringify(gameHistory));
                }
            } catch (e) {
                console.warn('Cannot save to localStorage for session history.');
            }

            // Store in global game history for leaderboard
            globalGameHistory.unshift(gameResult); // Add to beginning
            // You might want to limit the size of global history as well
            // For simplicity, let's keep it growing for now, but in a real app,
            // you'd typically have a server manage this.
            if (globalGameHistory.length > 100) globalGameHistory = globalGameHistory.slice(0, 100); // Keep last 100 global games
            saveGlobalGameHistory(); // Save the updated global history

            const finalResultDiv = document.getElementById('finalResult');
            let resultHTML = '';
            if (playerScore > computerScore) {
                resultHTML = `<h2>üéâ CONGRAT! üéâ</h2><div class="vs-text">YOU WIN!</div>`;
            } else if (computerScore > playerScore) {
                resultHTML = `<h2>üòû TOO BAD! üòû</h2><div class="vs-text">YOU LOSE!</div>`;
            } else {
                resultHTML = `<h2>ü§ù RESULTS! ü§ù</h2><div class="vs-text">DRAW MATCH!</div>`;
            }
            resultHTML += `<div class="score-display">${playerScore} - ${computerScore}</div>`;
            finalResultDiv.innerHTML = resultHTML;

            showModal('gameOver');
        }

        function restartGame() {
            startGame();
        }

        // Function to go back to login page (now index.html)
        function goToLogin() {
            gameRunning = false;
            gameStarted = false;
            clearInterval(gameTimer);
            localStorage.removeItem('currentPlayerName'); // Clear current player on exit
            window.location.href = 'index.html'; // Changed to index.html
        }

        // New function to go to the global leaderboard page (Klasemen.html)
        function goToGlobalLeaderboard() {
            gameRunning = false; // Stop the game if it's running
            clearInterval(gameTimer); // Clear any active game timer
            window.location.href = 'Klasemen.html'; // Navigate to the Klasemen page
        }


        // This function now only shows the SESSION (player's local) leaderboard
        function showLeaderboard() {
            const leaderboardContent = document.getElementById('leaderboardContent');
            if (gameHistory.length === 0) {
                leaderboardContent.innerHTML = '<p style="text-align: center;">Belum ada data permainan untuk sesi ini.</p>';
            } else {
                let html = '<div style="text-align: left;">';
                gameHistory.forEach((game) => {
                    const resultColor = game.result === 'Win' ? '#4CAF50' :
                                       (game.result === 'Lose' ? '#FF6B6B' : '#FFA726');
                    html += `
                        <div style="margin: 8px 0; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 8px; border-left: 3px solid ${resultColor};">
                            <strong>${game.date}</strong><br>
                            Skor: ${game.playerScore} (Anda) - ${game.computerScore} (CPU)<br>
                            <span style="color: ${resultColor}; font-weight: bold;">Result: ${game.result}</span>
                        </div>
                    `;
                });
                html += '</div>';
                leaderboardContent.innerHTML = html;
            }

            // Hide other modals before showing this one
            if (document.getElementById('startMenu').style.display === 'flex') {
                document.getElementById('startMenu').style.display = 'none';
                document.getElementById('leaderboard').dataset.cameFrom = 'startMenu'; // Mark where we came from
            } else if (document.getElementById('gameOver').style.display === 'flex') {
                document.getElementById('gameOver').style.display = 'none';
                document.getElementById('leaderboard').dataset.cameFrom = 'gameOver'; // Mark where we came from
            }
            showModal('leaderboard');
        }

        function hideLeaderboard() {
            document.getElementById('leaderboard').style.display = 'none';
            // Determine where to go back based on the 'cameFrom' dataset
            const cameFrom = document.getElementById('leaderboard').dataset.cameFrom;
            if (cameFrom === 'startMenu' || !gameStarted) { // If it came from start menu or game hasn't started yet
                 showModal('startMenu');
            } else { // Otherwise, go back to game over screen
                 showModal('gameOver');
            }
            // Clear the cameFrom attribute
            delete document.getElementById('leaderboard').dataset.cameFrom;
        }


        canvas.addEventListener('mousemove', (e) => { if (!gameRunning) return; updatePaddle(e.clientX); });
        canvas.addEventListener('touchstart', (e) => {
            if (!gameRunning) return; e.preventDefault(); if (e.touches.length > 0) { updatePaddle(e.touches[0].clientX); }
        }, { passive: false });
        canvas.addEventListener('touchmove', (e) => {
            if (!gameRunning) return; e.preventDefault(); if (e.touches.length > 0) { updatePaddle(e.touches[0].clientX); }
        }, { passive: false });

    </script>
</body>
</html>
